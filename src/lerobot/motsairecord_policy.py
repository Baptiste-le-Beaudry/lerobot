# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
# [License header reste identique...]

"""
Records a dataset. Actions for the robot can be either generated by teleoperation or by a policy.
Allows switching robot/policy at runtime without restarting the dataset.
"""

import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from pprint import pformat

from lerobot.cameras.opencv.configuration_opencv import OpenCVCameraConfig, ColorMode, Cv2Rotation
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig
from lerobot.datasets.image_writer import safe_stop_image_writer
from lerobot.datasets.lerobot_dataset import LeRobotDataset
from lerobot.datasets.utils import build_dataset_frame, hw_to_dataset_features
from lerobot.datasets.video_utils import VideoEncodingManager
from lerobot.policies.factory import make_policy
from lerobot.policies.pretrained import PreTrainedPolicy
from lerobot.robots import RobotConfig, make_robot_from_config
from lerobot.teleoperators import TeleoperatorConfig, make_teleoperator_from_config
from lerobot.teleoperators.keyboard.teleop_keyboard import KeyboardTeleop
from lerobot.teleoperators.so100_leader import SO100Leader
from lerobot.teleoperators.so101_leader import SO101Leader
from lerobot.teleoperators.koch_leader import KochLeader
from lerobot.teleoperators import Teleoperator
from lerobot.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
from lerobot.utils.robot_utils import busy_wait
from lerobot.utils.utils import get_safe_torch_device, init_logging, log_say

# âœ… Imports corrigÃ©s
# ðŸ”§ MODIFICATION UTILISATEUR : Si vous n'avez pas de module listen.py, commentez cette ligne
try:
    from .listen import SimpleSwitchDetector, create_voice_detector
except ImportError:
    # Fallback si le module listen n'existe pas
    class SimpleSwitchDetector:
        def _process_audio(self): return False
    def create_voice_detector(): return SimpleSwitchDetector()

import lerobot

# âœ… Variables globales pour gÃ©rer l'Ã©tat
shared_dataset: LeRobotDataset | None = None
switch_requested: bool = False

@dataclass
class DatasetRecordConfig:
    # Dataset identifier. By convention it should match '{hf_username}/{dataset_name}' (e.g. `lerobot/test`).
    repo_id: str
    # A short but accurate description of the task performed during the recording (e.g. "Pick the Lego block and drop it in the box on the right.")
    single_task: str
    # Root directory where the dataset will be stored (e.g. 'dataset/path').
    root: str | Path | None = None
    # Limit the frames per second.
    fps: int = 30
    # Number of seconds for data recording for each episode.
    episode_time_s: int | float = 60
    # Number of seconds for resetting the environment after each episode.
    reset_time_s: int | float = 3
    # Number of episodes to record.
    num_episodes: int = 50
    # Encode frames in the dataset into video
    video: bool = True
    # Upload dataset to Hugging Face hub.
    push_to_hub: bool = True
    # Upload on private repository on the Hugging Face hub.
    private: bool = False
    # Add tags to your dataset on the hub.
    tags: list[str] | None = None
    # Number of subprocesses handling the saving of frames as PNG.
    num_image_writer_processes: int = 0
    # Number of threads writing the frames as png images on disk, per camera.
    num_image_writer_threads_per_camera: int = 4
    # Number of episodes to record before batch encoding videos
    video_encoding_batch_size: int = 1

    def __post_init__(self):
        if self.single_task is None:
            raise ValueError("You need to provide a task as argument in `single_task`.")

@dataclass
class RecordConfig1:
    robot1: RobotConfig
    dataset: DatasetRecordConfig
    teleop1: TeleoperatorConfig | list[TeleoperatorConfig] | None = None
    policy1: PreTrainedConfig | None = None
    display_data: bool = False
    play_sounds: bool = True
    resume: bool = False

@dataclass
class RecordConfig2:
    robot2: RobotConfig
    dataset: DatasetRecordConfig
    teleop2: TeleoperatorConfig | list[TeleoperatorConfig] | None = None
    policy2: PreTrainedConfig | None = None
    policy2_repo_id: str | None = None  # âœ… Ajout pour repo_id direct
    display_data: bool = False
    play_sounds: bool = True
    resume: bool = False

@safe_stop_image_writer
def record_loop(
    robot,
    events,
    fps,
    dataset: LeRobotDataset | None = None,
    teleop=None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: float | None = None,
    single_task: str | None = None,
    display_data: bool = False,
    voice_detector: SimpleSwitchDetector | None = None,
):
    global switch_requested
    
    teleop_arm = teleop_keyboard = None
    if isinstance(teleop, list):
        teleop_keyboard = next((t for t in teleop if isinstance(t, KeyboardTeleop)), None)
        teleop_arm = next(
            (t for t in teleop if isinstance(t, (SO100Leader, SO101Leader, KochLeader))),
            None
        )

        if not (teleop_arm and teleop_keyboard and len(teleop) == 2 and robot.name == "lekiwi_client"):
            raise ValueError(
                "For multi-teleop, the list must contain exactly one KeyboardTeleop and one arm teleoperator. Currently only supported for LeKiwi robot."
            )
    
    if policy is not None:
        policy.reset()

    timestamp = 0
    start_episode_t = time.perf_counter()
    
    while timestamp < control_time_s:
        start_loop_t = time.perf_counter()

        if events["exit_early"]:
            events["exit_early"] = False
            break

        # âœ… VÃ©rification du switch
        # ðŸ”§ MODIFICATION UTILISATEUR : Ici se fait la dÃ©tection du mot-clÃ© pour changer de policy
        if voice_detector and voice_detector._process_audio():
            print("Switch detected, changing policy")
            switch_requested = True
            break

        observation = robot.get_observation()
        
        if policy is not None or dataset is not None:
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")

        if policy is not None:
            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
        elif policy is None and isinstance(teleop, Teleoperator):
            action = teleop.get_action()
        elif policy is None and isinstance(teleop, list):
            arm_action = teleop_arm.get_action()
            arm_action = {f"arm_{k}": v for k, v in arm_action.items()}

            keyboard_action = teleop_keyboard.get_action()
            base_action = robot._from_keyboard_to_base_action(keyboard_action)

            action = {**arm_action, **base_action} if len(base_action) > 0 else arm_action
        else:
            logging.info("No policy or teleoperator provided, skipping action generation.")
            continue

        sent_action = robot.send_action(action)

        if dataset is not None:
            action_frame = build_dataset_frame(dataset.features, sent_action, prefix="action")
            frame = {**observation_frame, **action_frame}
            dataset.add_frame(frame, task=single_task)

        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)

        timestamp = time.perf_counter() - start_episode_t

def create_dataset_from_config(dataset_config: DatasetRecordConfig, robot_config: RobotConfig) -> LeRobotDataset:
    """âœ… Fonction helper pour crÃ©er le dataset correctement"""
    
    # âœ… CrÃ©er une instance temporaire du robot pour obtenir ses features
    try:
        temp_robot = make_robot_from_config(robot_config)
        robot_observation_features = getattr(temp_robot, 'observation_features', {})
        robot_action_features = getattr(temp_robot, 'action_features', {})
    except Exception as e:
        logging.warning(f"Could not create robot to get features: {e}, using default features")
        # âœ… Fallback vers des features par dÃ©faut pour LeKiwi/SO100
        # ðŸ”§ MODIFICATION UTILISATEUR : Adapter ces features selon votre robot
        robot_observation_features = {
            "arm_pos": {"dtype": "float32", "shape": [6]},
            "arm_vel": {"dtype": "float32", "shape": [6]},
            "gripper_pos": {"dtype": "float32", "shape": [1]},
            "front": {"dtype": "uint8", "shape": [480, 640, 3]},
            "wrist": {"dtype": "uint8", "shape": [480, 640, 3]},
        }
        robot_action_features = {
            "arm_pos": {"dtype": "float32", "shape": [6]},
            "gripper_pos": {"dtype": "float32", "shape": [1]},
        }
    
    observation_features = hw_to_dataset_features(
        robot_observation_features,
        "observation",
        dataset_config.video
    )
    action_features = hw_to_dataset_features(
        robot_action_features,
        "action",
        dataset_config.video
    )
    
    # âœ… Combiner toutes les features
    features = {
        **observation_features,
        **action_features,
    }
    
    # âœ… CrÃ©er le dataset avec tous les paramÃ¨tres nÃ©cessaires
    dataset = LeRobotDataset.create(
        repo_id=dataset_config.repo_id,
        fps=dataset_config.fps,
        features=features,
        root=dataset_config.root,
        robot_type=getattr(robot_config, 'robot_type', 'lekiwi'),  # âœ… DÃ©faut vers lekiwi
        use_videos=dataset_config.video,
        tolerance_s=1e-4,
        image_writer_processes=dataset_config.num_image_writer_processes,
        image_writer_threads=dataset_config.num_image_writer_threads_per_camera,
        video_backend=None,
        batch_encoding_size=dataset_config.video_encoding_batch_size,
    )
    
    return dataset

def load_policy_from_hub(repo_id: str, dataset_meta=None):
    """âœ… Helper pour charger une policy depuis le hub"""
    try:
        from lerobot.policies.pretrained import PreTrainedPolicy
        return PreTrainedPolicy.from_pretrained(repo_id)
    except Exception as e:
        logging.warning(f"Could not load policy {repo_id}: {e}")
        return None

def record1(cfg: RecordConfig1) -> LeRobotDataset:
    global shared_dataset, switch_requested
    init_logging()
    logging.info(f"Starting record1 with config: {pformat(asdict(cfg))}")

    # âœ… CrÃ©er le dataset correctement
    if shared_dataset is None:
        shared_dataset = create_dataset_from_config(cfg.dataset, cfg.robot1)
    dataset = shared_dataset

    robot = make_robot_from_config(cfg.robot1)
    teleop = make_teleoperator_from_config(cfg.teleop1) if cfg.teleop1 else None
    
    # âœ… Chargement de policy1 - soit depuis config CLI, soit depuis repo_id
    policy = None
    if cfg.policy1:
        policy = make_policy(cfg.policy1, ds_meta=dataset.meta)
    elif hasattr(cfg, 'policy1_repo_id') and cfg.policy1_repo_id:
        policy = load_policy_from_hub(cfg.policy1_repo_id, dataset.meta)

    robot.connect()
    teleop and teleop.connect()
    listener, events = init_keyboard_listener()

    try:
        with VideoEncodingManager(dataset):
            recorded = 0
            while recorded < cfg.dataset.num_episodes and not events['stop_recording']:
                record_loop(
                    robot=robot,
                    events=events,
                    fps=cfg.dataset.fps,
                    teleop=teleop,
                    policy=policy,
                    dataset=dataset,
                    control_time_s=cfg.dataset.episode_time_s,
                    single_task=cfg.dataset.single_task,
                    display_data=cfg.display_data,
                    voice_detector=create_voice_detector(),
                )
                
                if switch_requested:
                    logging.info("Switch requested: exiting record1")
                    break
                    
                dataset.save_episode()
                recorded += 1

                if recorded < cfg.dataset.num_episodes:
                    record_loop(robot=robot, events=events, fps=cfg.dataset.fps,
                                control_time_s=cfg.dataset.reset_time_s)
                    
    finally:
        robot.disconnect()
        teleop and teleop.disconnect()
        listener and listener.stop()
        
    return dataset

def record2(cfg: RecordConfig2) -> LeRobotDataset:
    global shared_dataset, switch_requested
    init_logging()
    logging.info(f"Starting record2 with config: {pformat(asdict(cfg))}")

    dataset = shared_dataset
    if dataset is None:
        raise ValueError("shared_dataset should be initialized before calling record2")

    robot = make_robot_from_config(cfg.robot2)
    teleop = make_teleoperator_from_config(cfg.teleop2) if cfg.teleop2 else None
    
    # âœ… Chargement de policy2 - soit depuis config, soit depuis repo_id
    policy = None
    if cfg.policy2:
        policy = make_policy(cfg.policy2, ds_meta=dataset.meta)
    elif hasattr(cfg, 'policy2_repo_id') and cfg.policy2_repo_id:
        policy = load_policy_from_hub(cfg.policy2_repo_id, dataset.meta)

    robot.connect()
    teleop and teleop.connect()
    listener, events = init_keyboard_listener()

    try:
        with VideoEncodingManager(dataset):
            recorded = 0
            while recorded < cfg.dataset.num_episodes and not events['stop_recording']:
                record_loop(
                    robot=robot,
                    events=events,
                    fps=cfg.dataset.fps,
                    teleop=teleop,
                    policy=policy,
                    dataset=dataset,
                    control_time_s=cfg.dataset.episode_time_s,
                    single_task=cfg.dataset.single_task,
                    display_data=cfg.display_data,
                    voice_detector=create_voice_detector(),
                )
                
                if switch_requested:
                    logging.info("Switch requested: exiting record2")
                    break
                    
                dataset.save_episode()
                recorded += 1

                if recorded < cfg.dataset.num_episodes:
                    record_loop(robot=robot, events=events, fps=cfg.dataset.fps,
                                control_time_s=cfg.dataset.reset_time_s)
                    
    finally:
        robot.disconnect()
        teleop and teleop.disconnect()
        listener and listener.stop()
        
    return dataset

def policychoose(start_with: int, cfg1: RecordConfig1, cfg2: RecordConfig2):
    """âœ… Fonction pour alterner entre les policies"""
    global switch_requested
    current = start_with
    
    while True:
        switch_requested = False
        
        try:
            if current == 1:
                logging.info("Switching to policy 1")
                record1(cfg1)
                current = 2
            else:
                logging.info("Switching to policy 2") 
                record2(cfg2)
                current = 1
                
        except KeyboardInterrupt:
            logging.info("Recording interrupted by user")
            break
        except Exception as e:
            logging.error(f"Error during recording: {e}")
            break

# âœ… Imports corrigÃ©s
from lerobot.robots.lekiwi.config_lekiwi import LeKiwiConfig
from lerobot.teleoperators.so100_leader.config_so100_leader import SO100LeaderConfig
from lerobot.teleoperators.keyboard import KeyboardTeleopConfig

# âœ… Import SO100Follower correct
# ðŸ”§ MODIFICATION UTILISATEUR : Changez cette import selon votre type de robot
try:
    from lerobot.robots.so100_follower.config_so100_follower import SO100FollowerConfig
except ImportError:
    # Fallback si SO100FollowerConfig n'existe pas
    SO100FollowerConfig = LeKiwiConfig

@parser.wrap()
def main(cfg_cli: RecordConfig1):
    """âœ… Fonction main corrigÃ©e"""

    # âœ… Configuration robot1 correcte
    # ðŸ”§ MODIFICATION UTILISATEUR : Configurez ici votre premier robot
    robot1_cfg = SO100FollowerConfig(
        id="motsaikiwi",  # ðŸ”§ MODIFICATION UTILISATEUR : Changez l'ID de votre robot
        port="/dev/ttyACM0",  # ðŸ”§ MODIFICATION UTILISATEUR : Changez le port selon votre setup
        calibration_dir=None,
        cameras={
            "front": OpenCVCameraConfig(
                fps=30,
                width=640,
                height=480,
                index_or_path=0,  # ðŸ”§ MODIFICATION UTILISATEUR : Index de votre camÃ©ra avant
                color_mode=ColorMode.RGB,
                rotation=Cv2Rotation.NO_ROTATION,
                warmup_s=1,
            ),
            "wrist": OpenCVCameraConfig(
                fps=30,
                width=640,
                height=480,
                index_or_path=1,  # ðŸ”§ MODIFICATION UTILISATEUR : Index de votre camÃ©ra poignet
                color_mode=ColorMode.RGB,
                rotation=Cv2Rotation.NO_ROTATION,
                warmup_s=1,
            ),
        },
    )

    cfg1 = RecordConfig1(
        robot1=robot1_cfg,
        dataset=cfg_cli.dataset,
        teleop1=cfg_cli.teleop1,  # âœ… Utilise teleop1 du CLI
        policy1=cfg_cli.policy1,  # âœ… Utilise policy1 du CLI
        display_data=cfg_cli.display_data,
        play_sounds=cfg_cli.play_sounds,
        resume=cfg_cli.resume,
    )

    # âœ… SimplifiÃ© : utilise policy2_repo_id au lieu d'un config complexe
    # ðŸ”§ MODIFICATION UTILISATEUR : Configurez ici votre deuxiÃ¨me robot et policy
    cfg2 = RecordConfig2(
        robot2=LeKiwiConfig(
            id="motsaikiwi2",  # âœ… ID diffÃ©rent pour Ã©viter conflits
            calibration_dir=None,
            cameras={
                "front": OpenCVCameraConfig(
                    fps=30,
                    width=640,
                    height=480,
                    index_or_path=0,  # ðŸ”§ MODIFICATION UTILISATEUR : Index de votre camÃ©ra avant
                    color_mode=ColorMode.RGB,
                    rotation=Cv2Rotation.NO_ROTATION,
                    warmup_s=1,
                ),
                "wrist": OpenCVCameraConfig(
                    fps=30,
                    width=640,
                    height=480,
                    index_or_path=1,  # ðŸ”§ MODIFICATION UTILISATEUR : Index de votre camÃ©ra poignet
                    color_mode=ColorMode.RGB,
                    rotation=Cv2Rotation.NO_ROTATION,
                    warmup_s=1,
                )
            },
        ),
        teleop2=[
            SO100LeaderConfig(id="motsaileader2", port="COM4", calibration_dir=None),  # ðŸ”§ MODIFICATION UTILISATEUR : Port de votre tÃ©lÃ©opÃ©rateur
            KeyboardTeleopConfig(id="clavier2", calibration_dir=None, mock=False)
        ],
        policy2=None,  # âœ… Pas de config policy complexe
        policy2_repo_id="Baptiste-le-Beaudry/act_lekiwi_take_lego",  # ðŸ”§ MODIFICATION UTILISATEUR : Changez vers votre repo de policy
        dataset=cfg_cli.dataset,
        display_data=cfg_cli.display_data,
        play_sounds=cfg_cli.play_sounds,
        resume=cfg_cli.resume,
    )
    
    # âœ… Lancer la boucle de switch
    # ðŸ”§ MODIFICATION UTILISATEUR : Changez start_with=2 si vous voulez commencer avec la policy2
    policychoose(start_with=1, cfg1=cfg1, cfg2=cfg2)

if __name__ == "__main__":
    main()